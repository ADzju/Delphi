unit OutG_2022_5;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, VclTee.TeeGDIPlus, VCLTee.Series, Out_Graph_2_2015,
  VCLTee.TeEngine, Vcl.ExtCtrls, VCLTee.TeeProcs, VCLTee.Chart, Vcl.Grids, Printers, Vcl.StdCtrls;

type
  TForm5 = class(TForm)
    Chart2: TChart;
    Series15: TAreaSeries;
    Series8: TLineSeries;
    Series9: TLineSeries;
    Series10: TLineSeries;
    Series11: TLineSeries;
    Series12: TLineSeries;
    Chart1: TChart;
    Series2: TLineSeries;
    Series3: TLineSeries;
    Series4: TLineSeries;
    Series6: TLineSeries;
    Series5: TLineSeries;
    Series14: TBarSeries;
    Series17: TLineSeries;
    Chart3: TChart;
    Series13: TLineSeries;
    Series18: TLineSeries;
    Series19: TLineSeries;
    Result_Grid: TStringGrid;
    Label10: TLabel;
    Prodolgenie: TButton;
    Button1: TButton;
    PrintDialog1: TPrintDialog;
    PrinterSetupDialog1: TPrinterSetupDialog;
    Series20: TLineSeries;
    Series21: TLineSeries;
    Series22: TLineSeries;
    Series23: TLineSeries;
    Series1: TAreaSeries;
    Series7: TAreaSeries;
    StringGrid1: TStringGrid;
    Series16: TBarSeries;
   // procedure FormCreate(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure ProdolgenieClick(Sender: TObject);
    procedure Button1Click(Sender: TObject);

  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form5: TForm5;

implementation
uses Exp1, obrotk2022, GLVar_stat2022;

{$R *.dfm}

procedure FormCreate(Sender: TObject);
begin
Form5.WindowState:=wsMaximized;
Form5.Align:=alClient;
end;

 procedure TForm5.Button1Click(Sender: TObject);
begin
 Printer.PrinterIndex:=0;
 Printer.Orientation:=poLandscape;//poPortrait
 PrintScale:=poPrintToFit;//poProportional;//
 PrinterSetupDialog1.Execute;
 Print;
end;



procedure TForm5.FormClose(Sender: TObject; var Action: TCloseAction);
begin
//Form5.Destroy;
Form1.visible:=true;
end;
procedure TForm5.ProdolgenieClick(Sender: TObject);
begin
Form5.Visible:=false;
Form1.Visible:=true;
end;

end.


(* procedure TForm5.Button2Click(Sender: TObject);
  var i,i2: integer;
    begin
  // Application.CreateForm(TForm, Form4);
  // Form4.Visible:=true;
   with Form4 do begin
    for i:=Chart1.SeriesCount-1 downto 10 do Chart1.Series[i].Free;//очистить диаграмму} *)
 (*    t1:=0;  t2:=0; //SumNund:=0; SumNundCol:=0;
     Expl_sum:=0;
     Setlength(F_OutGar, 1+high(Hist_Stol));

    if MPirsN.Executed then begin MPirsN.Unsens:=0; MPirsN.Kol_Nakopl:=0; end;
    if MPirsS.Executed then begin MPirsS.Unsens:=0; MPirsS.Kol_Nakopl:=0; end;
        MGenet.Unsens:=0; MPir.Unsens:=0;  MSmirn.Unsens:=0;
        MPir.Kol_Nakopl:=0;
        MSmirn.Kol_Nakopl:=0;
        MGenet.Kol_Nakopl:=0;
      Screen.Cursor:=crHourGlass;
    Series1.Clear;  Series2.Clear;  Series3.Clear; Series4.Clear; Series5.Clear;
    Series6.Clear; Series7.Clear; Series8.Clear; Series14.Clear;  Series17.Clear;
     Ns1:=Chart1.SeriesCount;  // =7 (А2661 2661_01 2013)
        Nnew:=0;  Nakopl:=0;
      ColorPalettes.ApplyPalette( Chart1, 5{ 5 4}{7} );
       Chart1.Legend.Symbol.Continuous:=True;

      for I := 0 to NPrich+1 do  //
     // for I := 0 to high(Hist_Stol) do

           if Sum_PrichRow[i] then
          begin   // т.е. события-причины в столбце есть
          if Vidy_Otkazov[i].Dolya>0 then
  //        +' ('+ Format('%3.1f', [100*Vidy_Otkazov[i].Dolya/Kol_Izw])+'%)'+' случаев'); //);  //нижняя левая диагр основная
      DiaBarCol(Chart1, i, 0,  Vidy_Otkazov[i].Nazv_Prich + ' '+intToStr(Round(Vidy_Otkazov[i].Dolya))
          +' раз ( '+ Format('%3.1f', [100*Vidy_Otkazov[i].Dolya/Izd_Prived])+'%'+'/машину)'); //);  //нижняя левая диагр основная
             inc(Nnew);  // =5 (А2661 2661_01 2013)
                  end;
     // if SumNund>0 then
     //             begin
     //    DiaBarCol(Chart1, i, 0, 'Не идент.');  //нижняя левая диагр
      //          end;
     for i:=0 to high(Hist_Stol) do begin  //i111 цикл всей диаграммы
        t2:=round(Hist_Stol[i].time);
        K_Interval:=100/(t2-t1);           // величина, обратная весу интервала в 100 часах
    F_OutGar[i]:=CDF_Gauss(SRED,SKO,t2);   // накопление доли выбывших из гарантии
    Expl_sum:=Expl_sum+Hist_Stol[i].Sum;    // сумма известных отказов в эксплуатации
        N_ser:=0;
        for i2 := 0 to Mx_prich do  // 18 номера видов отказов
    if Sum_PrichRow[i2] then
         begin
         x2Str:=FloatToStr(t2);
         Sum_PrichCol[i2]:=Sum_PrichCol[i2]+Hist_Stol[i].Npr[i2];
    Chart1.series[Ns1+N_ser].Add(Hist_Stol[i].Npr[i2]*K_Interval/Izd_Prived,x2str,ColorArray[i2]);  // ++++++
//  Chart2.series[Ns2+N_ser].Add(Sum_PrichCol[i2]/Izd_Prived*KolOtk/Kol_izw,x2str,Chart1.ColorPalette[i2]);
 // if SumNund>0 then                              // отказы без названия
         //  SumNundCol:=SumNundCol+Hist_Stol[i].Nund;
      //   series14.Add(Hist_Stol[i].Nund*K_Interval/Izd_Prived,x2str);
        inc(N_ser);
        end; *)
  (*
    if MPirsN.Executed then Mpir:=MPirsN else if MPirsS.Executed then Mpir:=MPirsS; //
      if MPir.Executed then begin
    Chart1.series[1].Title:='Модель по Пирсону с учетом цензурирования';
    Chart1.series[2].Title:='Модель по Пирсону';
    Series2.Add(MPir.F_Weib[i]     *K_Interval*MPir.K_powtor,x2str);{Ch1 Line нецензурированный модельный массив по Пирсону}
    Series3.Add(MPir.Kol_F_priv[i] *K_Interval/Izd_Prived,x2str); {Ch1 Line итоговый модельный массив по Пирсону}
    Series8.Add(MPir.Unsens        * MPir.K_powtor, x2str);       {Ch2 накопл. модельный массив по Пирсону без цензурирования}
      *)
   (*   if MPirsN.Executed then begin                           // 1
    MPirsN.Unsens:=MPirsN.Unsens+MPirsN.F_Weib[i];                    // накопленные без учета цензурирования
    MPirsN.Kol_Nakopl:=MPirsN.Kol_Nakopl+MPirsN.Kol_F_Priv[i];        // накопленные известные отказы
      end;
      if MPirsS.Executed then begin                           // 2
    MPirsS.Unsens:=MPirsS.Unsens+MPirsS.F_Weib[i];                    // накопленные без учета цензурирования
    MPirsS.Kol_Nakopl:=MPirsS.Kol_Nakopl+MPirsS.Kol_F_Priv[i];        // накопленные
            end;
      if MPirsN.Executed then Mpir:=MPirsN else if MPirsS.Executed then Mpir:=MPirsS; // 3
      if MPir.Executed then begin                             //
    Chart1.series[1].Title:='Модель по Пирсону с учетом цензурирования';
    Chart1.series[2].Title:='Модель по Пирсону';
    Series8.Add(100*MPir.Unsens* MPir.K_powtor, x2str);      {Ch2 накопл. модельный массив по Пирсону без цензурирования}
    Series7.Add(100*MPir.Kol_Nakopl/Izd_Prived, x2str);
    Series2.Add(MPir.F_Weib[i]     *K_Interval*MPir.K_powtor,x2str);{Ch1 Line нецензурированный модельный массив по Пирсону}
    Series3.Add(MPir.Kol_F_priv[i] *K_Interval/Izd_Prived,x2str); {Ch1 Line итоговый модельный массив по Пирсону}
             end;
      if MGenet.Executed then begin                           // 4
    Chart1.series[4].Title:='Модель генетическая с учетом цензурирования';
    Chart1.series[6].Title:='Модель "генетическая"';
    MGenet.Unsens:=MGenet.Unsens+MGenet.F_Weib[i];
    MGenet.Kol_Nakopl:=MGenet.Kol_Nakopl+MGenet.Kol_F_Priv[i];
    Series5.Add(MGenet.F_Weib[i] *MGenet.K_powtor*K_Interval,x2str); {Ch1 генетическая модель без учета цензурирования}
    Series6.Add(MGenet.Kol_F_priv[i]/Izd_Prived  *K_Interval,x2str); {Ch1 итоговый генетич. модельный массив}

      end;                      //333
      if MSmirn.Executed then begin  //444                    // 5
    MSmirn.Kol_Nakopl:=MSmirn.Kol_Nakopl+MSmirn.Kol_F_Priv[i];
    Series4.Add(MSmirn.Kol_F_Priv[i]{*100}*K_Interval/Izd_Prived,x2str); {Ch1 итоговый модельный массив по Смирнову}
    Series9.Add(MSmirn.Kol_Nakopl/Izd_Prived, x2str);               {Ch2 накопленные отказы по Пирсону}
            end;                      //444
    Series1.Add (F_OutGar[i]*100,x2str);                                 //% выбывших из наблюдения рис 1
    Nakopl:=Nakopl+Hist_Stol[i].Sum;
  //  if Nakopl/Izd_Prived<=1 then
    Series17.Add(100*Nakopl/Izd_Prived,x2str);                            //% выбывших из наблюдения рис 2
                        t1:=t2;
                               end;   // i1111
    for I := 0 to Mx_prich do if Sum_PrichCol[i]>0 then  // 18
    Chart1.series[7].Title:='Накопление отказов, % от машин';
    tprev:=0;  t50:=0; tz50:=0;
       for i:=0 to High(MasProbl) do begin
       sumI:=SumI+1/(1-CDF_Gauss(SRED,SKO,MasProbl[i].time));
      if (t50=0) and ((I+1)/Izd_Prived>=0.5) then
        t50:=MasProbl[i].time-(MasProbl[i].time-tprev)*(Frac((I+1)-0.5*Izd_Prived));
      if (tz50=0) and ((SumI)/Izd_Prived>=0.5) then
       tz50:=MasProbl[i].time-(MasProbl[i].time-tprev)*Frac(SumI-0.5*Izd_Prived);
               tprev:=MasProbl[i].time;
             end;  // расчет t50 по фактическим временам отказов
   //     if t50=0 then Label2.Caption:='- данных недостаточно для оценки средней наработки на отказ'
   //     else begin
    //    Label2.Caption:='Накопление числа отказов, равного 0,5 численности парка- без учета цензурирования: '+Format('%7.1f',[t50])+' мч  ';
    //    Label3.Caption:='что эквивалентно t50% - с учетом цензурирования: '+Format('%7.1f',[tz50])+' мч  ';
    //    Label4.Caption:='Черная штрих-пунктирная линия - накопление числа отказов, % численности парка';
    //    Label5.Caption:='Интенсивность отказов от 200 часов до среднего окончания гарантии '+Format('%6.4f',[Pot08])+'/издел. на 1000 ч.';
     //              end;
   Label1.Caption:=Comment+' ('+FloatToStr(Kol_Izd_All)+' шт.,'+IntToStr(Kolotk) +' отказов)';
    Visible:=True;
      Screen.Cursor:=crDefault;
  end;
      //  end;
end;   *)

